from streetmapper import pipeline
import geopandas as gpd
import networkx as nx
import numpy as np
from shapely.geometry import Point, LineString
import pandas as pd
import rtree


def frontages_for_buildings(buildings, streets):
    """
    Given the set of available data, calculates building frontages for the given blocks.

    To only perform a more selective search, e.g. to focus on only a single area or even a single block, limit the
    `blocks` passed to the function.

    For implementation see `frontages_for_blockface`.

    Parameters
    ----------
    streets: nx.Graph
        Data for streets.
    buildings: gpd.GeoDataFrame
        Data for buildings.

    Returns
    -------
    # TODO
    """
    buildings_index = _create_index(buildings.geometry)

    for street in streets.edges(keys=False, data=True):
        _frontages_for_street(buildings, streets, street, buildings_index)

    return streets


def _create_index(srs):
    """
    Create a geospatial index of streets using the `rtree` package. Helper to `find_matching_street`, which uses this
    index to perform the actual join.
    """
    index = rtree.index.Index()

    for idx, feature in enumerate(srs):
        index.insert(idx, feature.bounds)

    return index


def _frontages_for_street(buildings, streets, street, index, step_size=0.01):
    """
    Given a single blockface and a set of buildings of interest, assigns each chunk of the blockface to the building
    out of the buildings of interest nearest to that blockface segment. The step size controls the size of the
    segments; specifying a lower value increases the accuracy of the algorithm, but also increases how long it takes
    to execute.

    The frontages are generated by performing an iterative search along the length of the blockface, asking at each
    point which building is nearest to that given point. The distance between points is controlled by the `step_size`.

    Parameters
    ----------
    buildings: gpd.GeoDataFrame
        Data on buildings.
    street: gpd.GeoSeries
        A single blockface.
    index: rtree.index.Index
        A geospatial index on buildings.
    step_size: float
        The step size, which controls the accuracy of the assessment (at the cost of speed).

    Returns
    -------
    # TODO
    """
    # TODO: use a smarter search strategy than simple iterative search
    street_start_id, street_end_id, street_meta = street

    if 'geometry' not in street_meta:
        street_geometry = LineString((
            (streets.node[street_start_id]['x'], streets.node[street_start_id]['y']),
            (streets.node[street_end_id]['x'], streets.node[street_end_id]['y'])
        ))
    else:
        street_geometry = street_meta['geometry']

    bldg_frontage_points = dict()
    search_space = np.arange(0, 1, step_size)

    for offset in search_space:
        search_point = street_geometry.interpolate(offset, normalized=True)
        nearest_bldg = next(index.nearest(search_point.bounds, 1))
        bldg_frontage_points[offset] = nearest_bldg

    strides = _collect_strides(bldg_frontage_points)
    frontage_geometries = _chop_line_segment_using_offsets(street_geometry, strides)
    _chop_line_segment_using_offsets(street_geometry, strides)

    for idx, stride_start_stop in enumerate(strides.keys()):
        building_matched = buildings.iloc[strides[stride_start_stop]]
        building_matched_id = building_matched.name
        frontage_geometry = frontage_geometries[idx]

        matches = {building_matched_id: (*stride_start_stop, frontage_geometry)}
        if 'buildings' not in street_meta:
            street_meta['buildings'] = matches
        else:
            street_meta['buildings'].update(matches)

    return street


def _collect_strides(point_observations):
    """
    Given a sequence of observations of which building is nearest to points on a shape (expressed as a percentage
    length out of 1), collects those observations into contiguous strides, thereby assigning buildings to chunks of the
    shape.

    Internal method to `frontages_for_blockfaces`.
    """
    point_obs_keys = list(point_observations.keys())
    curr_obs_start_offset = point_obs_keys[0]
    curr_obs_start_bldg = point_observations[point_obs_keys[0]]
    strides = dict()

    for point_obs in point_obs_keys[1:]:
        bldg_observed = point_observations[point_obs]
        if bldg_observed != curr_obs_start_bldg:
            strides[(curr_obs_start_offset, point_obs)] = curr_obs_start_bldg
            curr_obs_start_offset = point_obs
            curr_obs_start_bldg = bldg_observed
        else:
            continue

    strides[(curr_obs_start_offset, 1.00)] = bldg_observed
    return strides


def cut(line, distance):
    """
    Cuts a line in two at a distance from its starting point. Helper function.

    Modified version of algorithm found at http://toblerity.org/shapely/manual.html#object.project.
    """
    if distance == 0.0:
        return LineString()
    elif distance == 1.0:
        return LineString(line)
    elif distance < 0.0 or distance > 1.0:
        raise ValueError("Cannot cut a line using a ratio outside the range [0, 1]")

    coords = list(line.coords)
    for i, p in enumerate(coords):
        pd = line.project(Point(p), normalized=True)
        if pd == distance:
            return LineString(coords[:i + 1])
        elif pd > distance or i == len(coords) - 1:
            cp = line.interpolate(distance, normalized=True)
            return LineString(coords[:i] + [(cp.x, cp.y)])


def reverse(l):
    """
    Reverses LineString coordinates. Also known as changing the "winding direction" of the geometry. Helper function.
    """
    l_x, l_y = l.coords.xy
    l_x, l_y = l_x[::-1], l_y[::-1]
    return LineString(zip(l_x, l_y))


def _chop_line_segment_using_offsets(line, offsets):
    """
    Cuts a line into offset segments. Helper function.
    """
    offset_keys = list(offsets.keys())
    out = []

    for off_start, off_end in offset_keys:
        out_line = LineString(line.coords)
        orig_length = out_line.length

        # Reverse to cut off the start.
        out_line = reverse(out_line)
        out_line = cut(out_line, 1 - float(off_start))
        out_line = reverse(out_line)

        # Calculate the new cutoff end point, and apply it to the line.
        l_1_2 = (float(off_end) - float(off_start)) * orig_length
        l_1_3 = (1 - float(off_start)) * orig_length
        new_off_end = l_1_2 / l_1_3

        # Perform the cut.
        out_line = cut(out_line, new_off_end)
        out.append(np.nan if out_line is None else out_line)

    return out


def _buildings_left_right(street, buildings):
    street_buffer = street.buffer(0.01)
    buildings_nearby = buildings[buildings.contains(street_buffer)]
    for building in buildings_nearby:
        nearest_point = street.interpolate(
            building.centroid.project(street, normalized=True),
            normalized=True
        )
